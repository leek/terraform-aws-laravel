name: Deploy to AWS ECS

on:
  push:
    branches:
      - staging
      - uat
      - production

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  # ========================================
  # Configuration
  # ========================================
  APP_NAME: laravel
  AWS_REGION: us-east-1
  DOCKERFILE_PATH: docker/Dockerfile
  ECS_SERVICES: service,queue-worker,scheduler

  # ========================================
  # Standard Configuration
  # ========================================
  HUSKY: 0

jobs:
  deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Determine environment
        id: env
        run: |
          if [[ ${{ github.ref }} == 'refs/heads/production' ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          elif [[ ${{ github.ref }} == 'refs/heads/staging' ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          elif [[ ${{ github.ref }} == 'refs/heads/uat' ]]; then
            echo "environment=uat" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Generate version (production only)
        if: steps.env.outputs.environment == 'production'
        id: version
        run: |
          CURRENT_YEAR=$(date +%Y)
          CURRENT_MONTH=$(date +%m)

          # Get latest tag for current YYYY.MM.*
          PREFIX="${CURRENT_YEAR}.${CURRENT_MONTH}."
          LATEST_TAG=$(git --no-pager tag -l "${PREFIX}[0-9]*" --sort=-v:refname | head -n 1)

          if [ -z "$LATEST_TAG" ]; then
            # No tags exist, start with VERSION.0
            VERSION="${PREFIX}0"
          else
            TAG_PATCH=$(echo "$LATEST_TAG" | awk -F. '{print $3}' | sed 's/[^0-9].*$//')
            NEXT_PATCH=$(( ${TAG_PATCH:-0} + 1 ))
            VERSION="${PREFIX}${NEXT_PATCH}"
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"

          # Write version to VERSION file for the application to read
          echo "$VERSION" > VERSION
          echo "Created VERSION file with version: $VERSION"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          version: latest

      - name: Build and push base image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ env.DOCKERFILE_PATH }}
          target: base
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.APP_NAME }}-${{ steps.env.outputs.environment }}-base:latest
            ${{ steps.login-ecr.outputs.registry }}/${{ env.APP_NAME }}-${{ steps.env.outputs.environment }}-base:${{ github.sha }}
          platforms: linux/amd64
          cache-from: |
            type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.APP_NAME }}-${{ steps.env.outputs.environment }}-base:latest
            type=gha,scope=base
          cache-to: type=gha,mode=max,scope=base

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ env.DOCKERFILE_PATH }}
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.APP_NAME }}-${{ steps.env.outputs.environment }}:${{ github.sha }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.APP_NAME }}-${{ steps.env.outputs.environment }}:latest
          platforms: linux/amd64
          cache-from: |
            type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.APP_NAME }}-${{ steps.env.outputs.environment }}-base:latest
            type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.APP_NAME }}-${{ steps.env.outputs.environment }}:cache
            type=gha,scope=app
          cache-to: |
            type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.APP_NAME }}-${{ steps.env.outputs.environment }}:cache,mode=max
            type=gha,mode=max,scope=app

      - name: Deploy to AWS ECS
        env:
          ENVIRONMENT: ${{ steps.env.outputs.environment }}
        run: |
          echo "üöÄ Deploying to AWS ECS..."

          # Deploy all configured services
          IFS=',' read -ra SERVICES <<< "${{ env.ECS_SERVICES }}"
          for SERVICE_SUFFIX in "${SERVICES[@]}"; do
            SERVICE_NAME="${{ env.APP_NAME }}-${ENVIRONMENT}-${SERVICE_SUFFIX}"
            echo "üì¶ Deploying ${SERVICE_NAME}..."
            aws ecs update-service \
              --cluster ${{ env.APP_NAME }}-${ENVIRONMENT} \
              --service ${SERVICE_NAME} \
              --force-new-deployment
          done

      - name: Wait for ECS service to stabilize
        timeout-minutes: 15
        env:
          ENVIRONMENT: ${{ steps.env.outputs.environment }}
        run: |
          set +e  # Don't exit on error, we want to capture diagnostics

          echo "‚è≥ Waiting for ECS service to stabilize..."

          # Build service list from configuration
          IFS=',' read -ra SERVICE_SUFFIXES <<< "${{ env.ECS_SERVICES }}"
          SERVICES=()
          for SUFFIX in "${SERVICE_SUFFIXES[@]}"; do
            SERVICES+=("${{ env.APP_NAME }}-${ENVIRONMENT}-${SUFFIX}")
          done

          # Custom polling loop with configured timeout
          MAX_ATTEMPTS=60
          CHECK_INTERVAL=15
          ATTEMPT=0
          WAIT_EXIT_CODE=255

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))

            ALL_STABLE=true
            for SERVICE in "${SERVICES[@]}"; do
              echo "‚è≥ Checking $SERVICE..."

              DEPLOYMENTS=$(aws ecs describe-services \
                --cluster ${{ env.APP_NAME }}-${ENVIRONMENT} \
                --services "$SERVICE" \
                --query 'services[0].deployments[?rolloutState==`IN_PROGRESS`] | length(@)' \
                --output text)

              if [ "$DEPLOYMENTS" != "0" ]; then
                echo "‚è≥ $SERVICE: $DEPLOYMENTS deployment(s) still in progress..."
                ALL_STABLE=false
              fi
            done

            if [ "$ALL_STABLE" = true ]; then
              echo "‚úÖ All services stabilized after $ATTEMPT attempts"
              WAIT_EXIT_CODE=0
              break
            fi

            echo "‚è≥ Attempt $ATTEMPT/$MAX_ATTEMPTS..."
            sleep ${CHECK_INTERVAL}
          done

          if [ $WAIT_EXIT_CODE -ne 0 ]; then
            echo "‚è±Ô∏è Timeout: Service did not stabilize after $MAX_ATTEMPTS attempts"
          fi

          if [ $WAIT_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Service failed to stabilize. Gathering diagnostics..."
            echo ""

            # Get service details for primary service
            PRIMARY_SERVICE="${{ env.APP_NAME }}-${ENVIRONMENT}-service"
            echo "üìä Service Status:"
            aws ecs describe-services \
              --cluster ${{ env.APP_NAME }}-${ENVIRONMENT} \
              --services ${PRIMARY_SERVICE} \
              --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount,Pending:pendingCount,Deployments:deployments[*].{Status:rolloutState,Running:runningCount,Desired:desiredCount}}' \
              --output table

            echo ""
            echo "üîç Recent Task Events:"

            # Get stopped tasks from the last 30 minutes
            STOPPED_TASKS=$(aws ecs list-tasks \
              --cluster ${{ env.APP_NAME }}-${ENVIRONMENT} \
              --service-name ${PRIMARY_SERVICE} \
              --desired-status STOPPED \
              --query 'taskArns[0:5]' \
              --output text)

            if [ -n "$STOPPED_TASKS" ]; then
              for TASK_ARN in $STOPPED_TASKS; do
                echo ""
                echo "Task: $(basename $TASK_ARN)"

                # Get task details including stop reason
                TASK_INFO=$(aws ecs describe-tasks \
                  --cluster ${{ env.APP_NAME }}-${ENVIRONMENT} \
                  --tasks "$TASK_ARN" \
                  --query 'tasks[0]' \
                  --output json)

                EXIT_CODE=$(echo "$TASK_INFO" | jq -r '.containers[0].exitCode // "N/A"')
                STOP_CODE=$(echo "$TASK_INFO" | jq -r '.stopCode // "N/A"')

                # Only show full details if it's an actual failure (non-zero exit or TaskFailedToStart)
                if [ "$EXIT_CODE" != "0" ] && [ "$EXIT_CODE" != "N/A" ] || [ "$STOP_CODE" = "TaskFailedToStart" ]; then
                  echo "$TASK_INFO" | jq -r '
                    "  ‚ùå FAILURE - Stopped Reason: \(.stoppedReason // "N/A")",
                    "  Stop Code: \(.stopCode // "N/A")",
                    "  Last Status: \(.lastStatus // "N/A")",
                    "  Containers:",
                    (.containers[] | "    - \(.name): exit=\(.exitCode // "N/A"), reason=\(.reason // "none")")
                  '

                  # Get CloudWatch logs for this task (last 20 lines)
                  TASK_ID=$(basename $TASK_ARN)
                  LOG_STREAM="ecs/app/$TASK_ID"

                  echo "  Recent Logs (last 20 lines):"
                  aws logs get-log-events \
                    --log-group-name "/aws/ecs/${{ env.APP_NAME }}-$ENVIRONMENT" \
                    --log-stream-name "$LOG_STREAM" \
                    --limit 20 \
                    --query 'events[*].message' \
                    --output text 2>/dev/null | sed 's/^/    /' || echo "    (no logs available)"

                  echo "  ---"
                else
                  echo "  ‚úÖ Stopped normally (exit code: $EXIT_CODE)"
                fi
              done
            else
              echo "  No stopped tasks found"
            fi

            echo ""
            echo "üí° Check the AWS Console for more details: https://console.aws.amazon.com/ecs/v2/clusters/${{ env.APP_NAME }}-$ENVIRONMENT/services/${{ env.APP_NAME }}-$ENVIRONMENT-service/health"

            exit $WAIT_EXIT_CODE
          fi

          echo "‚úÖ Service stabilized successfully"

      - name: Run post-deploy Laravel commands
        timeout-minutes: 20
        env:
          CLUSTER: ${{ env.APP_NAME }}-${{ steps.env.outputs.environment }}
          SERVICE: ${{ env.APP_NAME }}-${{ steps.env.outputs.environment }}-service
        run: |
          set -euo pipefail

          # Ensure jq is available (Ubuntu runners usually have it, but just in case)
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y jq
          fi

          echo "üîé Describe service ${SERVICE} on ${CLUSTER}"
          SVC_JSON=$(aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --output json)
          if [ "$(echo "$SVC_JSON" | jq -r '.services | length')" -eq 0 ]; then
            echo "Service not found"; exit 1
          fi

          TD_ARN=$(echo "$SVC_JSON" | jq -r '.services[0].taskDefinition')
          echo "üîß Task definition: $TD_ARN"

          # Network config (awsvpc) is taken from the service, if present
          SUBNETS_JSON=$(echo "$SVC_JSON" | jq -c '.services[0].networkConfiguration.awsvpcConfiguration.subnets // empty')
          SGRPS_JSON=$(echo "$SVC_JSON" | jq -c '.services[0].networkConfiguration.awsvpcConfiguration.securityGroups // empty')
          ASSIGN_PUBLIC_IP=$(echo "$SVC_JSON" | jq -r '.services[0].networkConfiguration.awsvpcConfiguration.assignPublicIp // empty')

          NETCFG_ARG=""
          if [ -n "${SUBNETS_JSON:-}" ] && [ -n "${SGRPS_JSON:-}" ] && [ -n "${ASSIGN_PUBLIC_IP:-}" ]; then
            NETCFG_ARG="--network-configuration awsvpcConfiguration={subnets=${SUBNETS_JSON},securityGroups=${SGRPS_JSON},assignPublicIp=${ASSIGN_PUBLIC_IP}}"
            echo "üåê Using service awsvpc network configuration"
          else
            echo "üåê No awsvpc network config on service; assuming EC2/bridge host networking"
          fi

          # Capacity providers vs launch type
          CP_JSON=$(echo "$SVC_JSON" | jq -c '.services[0].capacityProviderStrategy // []')
          CP_ARG=""
          LT_ARG=""
          if [ "$(echo "$CP_JSON" | jq 'length')" -gt 0 ]; then
            # Build --capacity-provider-strategy arg list
            CP_ARG="--capacity-provider-strategy"
            while read -r line; do
              CP_ARG="$CP_ARG $line"
            done < <(echo "$CP_JSON" | jq -r '.[] | "capacityProvider=\(.capacityProvider),weight=\(.weight // 1),base=\(.base // 0)"')
            echo "‚öñÔ∏è  Using service capacity provider strategy"
          else
            echo "üîé Describe task definition to infer launch type"
            TD_JSON=$(aws ecs describe-task-definition --task-definition "$TD_ARN" --include TAGS --output json)
            if echo "$TD_JSON" | jq -e '.taskDefinition.requiresCompatibilities[] | select(.=="FARGATE")' >/dev/null; then
              LT_ARG="--launch-type FARGATE"
              echo "üö¢ Using launch type: FARGATE"
            else
              LT_ARG="--launch-type EC2"
              echo "üö¢ Using launch type: EC2"
            fi
          fi

          # Pick a container name (default to first container in TD)
          if [ -z "${TD_JSON+x}" ]; then
            TD_JSON=$(aws ecs describe-task-definition --task-definition "$TD_ARN" --include TAGS --output json)
          fi
          CONTAINER_NAME=$(echo "$TD_JSON" | jq -r '.taskDefinition.containerDefinitions[0].name')
          echo "üì¶ Container to run: ${CONTAINER_NAME}"

          # Build the overrides to run Laravel post-deploy commands
          # Note: All caches (except config) are baked into the Docker image at build time
          # Config cache happens automatically in entrypoint.sh for all containers
          # We only need to run migrations here during deployment
          cat > overrides.json <<JSON
          {
            "containerOverrides": [{
              "name": "${CONTAINER_NAME}",
              "command": [
                "sh","-lc",
                "php artisan down && php artisan migrate --force --isolated && php artisan up"
              ]
            }]
          }
          JSON

          echo "üöö ecs run-task ..."
          # shellcheck disable=SC2086
          RUN_ARN=$(aws ecs run-task \
            --cluster "$CLUSTER" \
            --task-definition "$TD_ARN" \
            ${CP_ARG:-} \
            ${LT_ARG:-} \
            ${NETCFG_ARG:-} \
            --overrides file://overrides.json \
            --query 'tasks[0].taskArn' \
            --output text)

          if [ -z "$RUN_ARN" ] || [ "$RUN_ARN" = "None" ]; then
            echo "‚ùå Failed to start one-off task"; exit 1
          fi
          echo "üÜî Started task: $RUN_ARN"

          echo "‚è≥ Waiting for task to stop..."
          # Retry aws ecs wait up to 5 times to handle transient connection issues
          MAX_RETRIES=5
          RETRY=0
          WAIT_SUCCESS=false

          while [ "$RETRY" -lt "$MAX_RETRIES" ]; do
            RETRY=$((RETRY + 1))
            echo "‚è≥ Wait attempt $RETRY/$MAX_RETRIES..."

            if aws ecs wait tasks-stopped --cluster "$CLUSTER" --tasks "$RUN_ARN"; then
              WAIT_SUCCESS=true
              break
            else
              echo "‚ö†Ô∏è  Wait command failed (attempt $RETRY/$MAX_RETRIES)"
              if [ "$RETRY" -lt "$MAX_RETRIES" ]; then
                echo "‚è≥ Retrying in 10 seconds..."
                sleep 10
              fi
            fi
          done

          if [ "$WAIT_SUCCESS" = false ]; then
            echo "‚ö†Ô∏è  Wait command failed after $MAX_RETRIES attempts, checking task status anyway..."
          fi

          # Verify task is actually stopped
          TASK_STATUS=$(aws ecs describe-tasks \
            --cluster "$CLUSTER" \
            --tasks "$RUN_ARN" \
            --query 'tasks[0].lastStatus' \
            --output text)

          if [ "$TASK_STATUS" != "STOPPED" ]; then
            echo "‚ùå Task is not stopped (status: $TASK_STATUS), cannot verify completion"
            exit 1
          fi

          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster "$CLUSTER" \
            --tasks "$RUN_ARN" \
            --query 'tasks[0].containers[?name==`'"$CONTAINER_NAME"'`].exitCode | [0]' \
            --output text)

          echo "Task exit code: $EXIT_CODE"
          if [ "$EXIT_CODE" != "0" ]; then
            echo "‚ùå Post-deploy commands failed"; exit "$EXIT_CODE"
          fi
          echo "‚úÖ Post-deploy commands completed"

      - name: Create GitHub Release (production only)
        if: steps.env.outputs.environment == 'production'
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.version.outputs.version }}
          name: Release ${{ steps.version.outputs.version }}
          body: |
            ## Deployment Information
            - **Environment**: Production
            - **Commit**: ${{ github.sha }}
            - **Deployed by**: @${{ github.actor }}
            - **Deployment Date**: ${{ github.event.head_commit.timestamp }}

            ## Changes
            ${{ github.event.head_commit.message }}
          draft: false
          prerelease: false
          makeLatest: true
          generateReleaseNotes: true
          allowUpdates: true

      - name: Create Sentry release
        uses: getsentry/action-release@v3
        continue-on-error: true
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
        with:
          environment: ${{ steps.env.outputs.environment }}
          release: ${{ steps.env.outputs.environment == 'production' && steps.version.outputs.version || github.sha }}
          disable_telemetry: true

      - name: Microsoft Teams Notification
        if: failure()
        uses: jdcargile/ms-teams-notification@v1.4
        continue-on-error: true
        with:
          github-token: ${{ github.token }}
          ms-teams-webhook-uri: ${{ secrets.MS_TEAMS_WEBHOOK_URI }}
          notification-summary: "Failed to deploy to ${{ steps.env.outputs.environment }} environment."
          notification-color: dc3545
